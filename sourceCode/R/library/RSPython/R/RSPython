getNumPythonConverters <-
#
# Returns the number of converters
# registered internally in a C list/table
# for performing the conversion between R and Java. 
#   F represents from Java to R,
#   T represents from Java to R.
# This is vectorized in the type or direction of converter.

# By default, it returns both.

function(which = c(fromPython=F, toPython=T))
{
 ans <- integer(0)
 for(i in which)
  ans <- c(ans, .Call("RPython_getNumConverters",as.logical(i))) 

 names(ans) <- names(which)

 ans
}


getPythonConverterDescriptions <-
function(which = c(fromPython=F, toPython=T))
{
 ans <- vector("list", length(which))
 for(i in 1:length(which)) {
  ans[[i]] <- .Call("RPython_getConverterDescriptions", as.logical(which[i]))
 }

 names(ans) <- names(which)

 ans
}
.First.lib <-
function(libname, pkgname) {
      # load the shared library!
 library.dynam("RSPython", pkgname, libname)
 setPythonHandler(referenceManager())
}
.Python <- 
#
# Invoke a Python function.
#
#
function(func, ..., .module=NULL, .convert=T)
{
 isPythonInitialized(T)

 args <- list(...)
 .Call("RPy_callPython", as.character(func), args, names(args), as.character(.module), as.logical(.convert), F)
}


.PythonNew <-
#
# Create a new Python object
#
# className - the name of the class of which we create an instance
# ... - arguments to the constructor (__init__ method)
# .module - the name of the module in which to find the class.
# .convert - indicates whether to attempt to convert the resulting object
#    to an R object or leave as a Python reference.
#
function(className, ..., .module=NULL, .convert = F)
{
 isPythonInitialized(T)

  args <- list(...)
 .Call("RPy_callPython", as.character(className),  args, names(args),
                           as.character(.module), as.logical(.convert), T)

#  .Call("RS_PythonNewObject", as.character(className), as.character(.module),
#                     args, names(args), as.logical(.convert))
}


.PythonEvalFile <-
#
# Evaluate the contents of a file containing Python expressions.
#
function(cmd, ..., .module = NULL, .convert = T)
{
 isPythonInitialized(T)

 .PythonEval(cmd, ..., .module = .module, .convert = .convert, .isFile = T)
}

.PythonEval <-
#
# Eval a Python expression as a string or a file.
#
function(cmd, ..., .module = NULL, .convert = T, .isFile = F)
{
 isPythonInitialized(T)

 .Call("RS_PythonEval", as.character(cmd), args, names(args), as.character(.module), as.logical(.convert), as.logical(.isFile))
}

.PythonMethod <-
#
# Call a method on Python object.
# ref - the reference to the Python object.
# method - the name of the method to invoke
# ...   - arguments to pass to the method, which  can be named and this
#         will be used when matching the arguments.
# .convert - logical value indicating whether to attempt to convert the result 
#           to an R object or leave as a Python reference object in R.
function(ref, method, ..., .convert = T)
{
 isPythonInitialized(T)

  args <- list(...)
 .Call("RPy_callMethod", ref, as.character(method), args, names(args), as.logical(.convert))
}


.PythonInit <-
#
# Initialize the Python interpreter.
#
# If there is no PYTHONPATH set, then we set our version so that
# one can find the RS modules.
#
# If there is a PYTHONPATH already set, then we take it and append
# our value to it. This can be inhibited by specifying `merge = F'
#
# Finally, if there is a non-null value for the path argument, then 
# we use that as the value for PYTHONPATH. Again, if merge = T, we 
# append the RS directories to it.

# If merge is T, then we take whatever value for path is given
# and append it to the current value of PYTHONPATH
#
function(path = NULL, merge = T, warn = F, force=T) { 

 if(!force && isPythonInitialized(F)) {
   warning("The Python interpreter was already initialized")
   return(T)
 }

 path <- .PythonPath(path=path, merge=merge)

 if(!is.null(path) && path != "")
   Sys.putenv("PYTHONPATH"=path)

 status <- .Call("InitPython")
 if(warn) {
    warning("Implicit initialization of the Python interpreter with default settings")  
 }
 invisible(status)
}

.PythonPath <-
function(path=NULL, merge=T)
{
 dirSep <- ifelse(R.version$os == "Win32", ";", ":",)

 if(length(path) > 1)
   path <- paste(path, collapse=dirSep)

 pyPath <- ifelse(is.null(path), Sys.getenv("PYTHONPATH") , path)

 ourPath <- paste(system.file("Python", package="RSPython"),
                  system.file("libs",   package="RSPython"), 
                  sep=dirSep)


 if(as.logical(merge)) {
  if(pyPath != "")
   pyPath <- paste(pyPath, ourPath, sep=dirSep)
  else
   pyPath <- ourPath
 }

 return(pyPath)
}


.PythonTerminate <- 
#
# Initialize the Python interpreter.
#
#
function() {
 isPythonInitialized()
  .Call("RS_PythonTerminatePython")
}

isPythonInitialized <-
function(init = F)
{
 status <- .Call("RS_PythonIsInitialized")
 if(!status && init) {
   .PythonInit(warn = T)
   status <- T
 }
 return(status)
}
"$.PythonReference" <-
#
# 
#
function(obj,name)
{
 function(...) {
  .PythonMethod(as.character(name),..., ref=obj)
 }
}

"[[.PythonReference" <-
function(x, i, ..., .convert = T)
{
  .Call("RPy_getAttr", x, as.character(i), as.logical(.convert))
}  

foreignReference <-
#
# Create an object that is used to represent a local R object
# in a call to a foreign system (Java), optionally specifying
# a name by which it is to be stored locally and known externally
# and the name of one or more classes/interfaces that should be used
# to represent it. 
# The last of these is interpreted by the remote system
function(obj, id=NULL, className=NULL, targetClasses=NULL, register=T)
{

 if(missing(targetClasses)) {
   if(!is.null(class(obj)))
      targetClasses <- "RForeignList"
 }
  
 ref <- list(id=as.character(id), value=obj,
             className=as.character(className),
             targetClasses=as.character(targetClasses),
             type=typeof(obj), classes=class(obj))
 class(ref) <- ifelse(missing(id), "AnonymousRReference", "NamedRReference")


  if(register) {
   ref <- getPythonHandler()$addReference(ref)
  }

 ref
}
importPythonModule <-
function(name, all=T)
{
 if(as.logical(all))
   cmd <- paste("from", name, "import *")
 else
   cmd <- paste("import", name)
 .PythonEval(cmd)
}

pythonModuleNames <-
function(name)
{
 .Call("RS_PythonGetModuleNames", as.character(name))
}

pythonModuleTypes <-
function(name)
{
 .Call("RS_PythonGetModuleTypes", as.character(name))
}

referenceManager <- 
#
# Closure generator that creates an object to be passed as the  
# database mechanism for storing foreign references, and also
# perform the dispatching of the calls to these references.
#
function() 
{
    # used to compute a unique identifier
  total <- 0
  references <- list()

  createReference <- function(obj, register=T) {
   r <- foreignReference(obj, register=register)
   return(r)
  }

  addReference <- 
     # add a reference to the database.
     #
   function(obj) {
     if(length(obj$id) == 0) {
        total <<- total + 1       
        key <- as.character(total)
        obj$id <- key
      } else 
        key <- obj$id

     references[[key]] <<- obj

    invisible(obj)
  }

  getReference <- function(id, asIs = F) {
    tmp <- references[[id]]
    if(!asIs)
      tmp <- tmp$value
    return(tmp)
  }

  remove <- 
    # Delete a reference from the database by specifying the object
    # (i.e. the reference) or the identifier. 
  function(id) {
   if(!is.na(match("foreignReference",class(id)))) {
     key <- id$id
   } else
    key <- as.character(id)

    references <<- references[[-c(id)]]
  }

  handler <- function(id, methodName, returnType, signature, javaObject, args, stackCount = -1)
  {
    restart(T)
    stackCount <- stackCount + 1
    if(stackCount > 0) {
      return(list(NULL, paste("Error in the Python handler invocation of",methodName,"for",id)))
    }

      # resolve the reference
     obj <- references[[id]]
     
      # Now, if it is an foreignReference object, look for its value field.
      # That is what we will invoke the function on or in.
     obj <- obj$value

       # If the value is a list and it has a function stored using the methodName,
       # we'll call it. Otherwise, we just look for a global function and then 
       # put the object onto the front of the argument list. We do this iff
       # obj is non-null. This allows data-less methods to be used.
     if(is.list(obj) && !is.null(obj[[methodName]]) && is.function(obj[[methodName]])) {
       f <- obj[[methodName]]
     } else {
       f <- get(methodName, mode="function")
       if(!is.null(obj))
        args <- c(obj, args)
     }

       # Create the call by creating an expression with the unravelled arguments
       # used rather than treating them as a single argument which is a list.
       # I imagine there is a function that can do this expansion, but I can't
       # recall it. And since we already have exactly that code in C for other purposes,
       # we use it.
      ans <- eval(.Call("RPython_createCall", f, args))

   return(list(ans))
  }


  mgr <- list(handler=handler, 
              createReference = createReference, 
              addReference = addReference, 
              remove=remove,
              getReference = getReference,
              references=function() {references}, 
              total=function() {total}
             )
  class(mgr) <- "ForeignReferenceManager"

  return(mgr)
}


setPythonHandler <-
function(handler)
{
   .Call("RPython_setDefaultHandlerFunction", handler)
}

getPythonHandler <-
function()
{
   .Call("RPython_defaultHandlerFunction")
}
getPythonReferenceIDs <-
function()
{
 .Call("RS_getPythonReferenceIDs")
}

getSuperClasses <-
function(obj, module=NULL)
{
 if(!missing(module))
  obj <- c(obj, module)

 .Call("RS_PygetSuperClasses", obj)
}

# e.g.
#  getSuperClasses("addinfourl", "urllib")
# u <- .PythonNew("urlopen", "http://www.omegahat.org/index.html", .module="urllib")
#
# If the PYTHONPATH environment variable includes system.file("", pkg="RSPython")
#    getSuperClasses("A", "hierarchy")



pythonMethods <- 
#
# Get the methods in a Python object or class
# all  whether to query the base classes of this class
#      or just do a shallow query.
function(obj, all=F)
{
  .Call("RS_PythonGetMethods", obj, as.logical(all))
}


pythonFunction <-
function(obj, module=NULL)
{
 if(!missing(module))
  obj <- c(obj, module)

 .Call("RS_Python_describeFunction", obj)
}

.First.lib <-
function(libname, pkgname) {
      # load the shared library!
 library.dynam("RSPython", pkgname, libname)
 setPythonHandler(referenceManager())
}
